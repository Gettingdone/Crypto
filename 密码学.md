---

title: 密码学
tags: 
notebook: 研究生
---





# 密码编码学与网络安全

## 绪论

### 安全需求

**认证**、**访问控制**、**保密性**、**完整性**、**不可否认性**

**保密、完整、可用**

**可信、可控**

### 风险来源

分类：

大类：物理攻击、网络攻击、恶意代码、安全管理

* 电磁泄漏

  辐射泄漏、传导泄漏

* 芯片的脆弱性

  芯片存在设计缺陷；后门

* 数据库的安全漏洞

  数据库自身存在安全缺陷、错误的部署和配置、SQL注入、通信协议、存储介质

* 操作系统的安全漏洞

  操作系统软件在设计上缺陷或错误

* 通信协议的安全漏洞

  协议的开放性、协议的设计缺陷、代码实现的缺陷

* 移动存储介质的安全漏洞

  移动存储介质在信息系统之间随意使用，造成病毒感染和传播；将内部介质非法带出使用，造成数据外泄

### 信息安全理解

* 没有绝对的标准
  * 安全的判别标准不同
  * 安全都是相对的
* 没有绝对的保证
  * 时间和空间的复杂性
  * 不是无懈可击：无条件的安全，计算安全
  * 任何系统都有漏洞和缺陷
  * 安全是有生存周期的
* 没有完美系统
  * 对可用性，可靠性，可信性的理解
* 可用：
  * 一定条件下的合理性
  * 开放性和安全性是一对矛盾，贯穿发展始终，长期对抗
  * 不可能一劳永逸、绝对安全的系统安全策略和安全机制

### 密码学组成

* 密码编码学
  * 密码协议
    * 密钥交换协议
    * 鉴别(鉴权)协议
    * 数字签名协议
  * 密码技术
    * 密钥管理
    * 密钥长度
    * 算法类型和模式
  * 密码算法
    * 古典密码算法
    * 对称密码算法
    * 非对称密码算法
    * 单向散列算法
* 密码分析学
  * 线性分析方法
  * 非线性分析方法
  * 穷举法

### 信息安全体系结构

协议层次+信息系统构成单元+安全服务(安全机制)

![image-20210416200613935](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210416200613935.png)

![image-20210416200628182](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210416200628182.png)

##### 安全体系包含的基本要素：

* 安全需求：信息系统要达到的安全服务要求，是制定安全策略和建立安全模型的前提
* 安全策略：指用于限定一个系统、实体或对象进行安全相关活动的规则集
* 安全机制：实现安全信息系统安全需求及安全策略的各种措施
* 安全模型：用于准确描述系统在功能和结构上的安全特性，反映了一定的安全策略

##### 安全服务：

* 认证
  * 鉴别或认证，验证系统实体和系统资源的身份
  * 同等实体认证和数据来源的认证
* 访问控制
  * 控制授权范围内的信息流向及行为方式
* 保密性
  * 信息不被泄漏给非授权用户、实体或过程，或供其利用的特性
  * 连接保密性、非连接保密性、选择域保密性和流量保密性
* 完整性
  * 未经授权不能改变的特性
* 不可否认性
  * 信息交互过程中，确信参与者的真实统一性
  * 源不可否认，宿不可否认



## 密码学的数学基础

### 有限域

#### 群&环&域

![image-20210416212251772](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210416212251772.png)

群、环和域：数学理论中的一个分支，即抽象代数或称为近世代数的基本元素；关心的是使集合上的两个元素运算后得到集合中的第三个元素

##### 群

群G，记为{G,·}，定义了一个二元运算的集合，G中的每个序偶(a,b)通过运算生成G中的元素(a·b)

交换群即是满足交换律的群，a·b=b·a

循环群：群中的每个元素都是一个固定元素a的幂a<sup>k</sup>，总是交换群

* 封闭性
* 结合律
* 单位元
* 逆元
* （交换群）

##### 环

环R，记为{R,+,×}，两个运算称为加法和乘法，加法满足以上五种，乘法满足：封闭性、结合律、分配率、乘法单位元、无零因子

环就是一个集合：在其上进行加法、减法和乘法而不脱离该集合

##### 域

域F，{F,+,×}，乘法和加法，是一个集合，在其上进行加法、减法、乘法、除法而不脱离集合

![image-20210416220128958](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210416220128958.png)



##### 有限域

阶为p<sup>n</sup>的有限域一般记为GF(p<sup>n</sup>)

* GF(p)，只有p个元素的域，p是一个素数,GF(p)被定义为整数{0,1,2...p-1}的集合Z<sub>p</sub>
  * 乘法逆元(w<sup>-1</sup>)：任意w≠0∈Z<sub>p</sub>，存在z使得w×z≡1 mod p
  * Z<sub>p</sub>中的任一整数都有乘法逆元



* GF(2<sup>n</sup>)：包含2<sup>n</sup>个元素的域



#### 欧几里得算法

求两个数的最大公因子

```c++
int gcd(a,b)
{
	return b==0?a:gcd(b,a%b);
}
```





#### 密码学为什么要采用有限域？明文、密文和密钥必须属于某个有限域



#### 为什么采用模运算？



#### 为什么密码学要采用GF(2<sup>n</sup>)形式的有限域，而不采用GF(p)形式的有限域？



#### RSA算法的原理





### 数论基础

整除

性质：

1. 若b|a，c|b，则c|a；
2. 若a|1，则a=±1；若a|b且b|a，则a=±b；
3. 对任一b（b≠0），则b|0；
4. 若b|g，b|h，则对任意整数m，n有b|(mg+nh);



### 欧拉函数

问题：给定正整数n，问小于等于n的正整数中，有多少个与n构成互质关系？

情况分类：[φ(n)为小于等于n的正整数中与n互质的数的个数]

1. n=1

2. n为质数，与小于他的每一个数都构成互质关系

3. 质数k，n=k<sup>n</sup>，与小于k的每个数都成互质关系

4. 质数：p1，p2，n=p1*p2，那么积的欧拉函数等于各个因子的欧拉函数之积:

   φ(n) = φ(p1p2) = φ(p1)φ(p2)



欧拉函数公式：p取到n的所有质因数

![image-20210614225022393](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210614225022393.png)

欧拉定理：

​	如果正整数n和整数a互质，那么就有：

![image-20210614225200268](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210614225200268.png)

### 费马小定理

是欧拉定理的一个特殊情况：n和a的最大公因数为1

p是素数，a是整数且不能被p整除，则：a<sup>(p-1)</sup>≡1 mod p



[密码学中的素数以及对称加密](https://blog.csdn.net/dog250/article/details/38958637)

### 素数

计算机能够处理千级次幂范围的大数，但是无法处理无限的抽象范围。那么如何生成一个有限的集合，方法很多，最显而易见的就是取模，整个实数集合对5取模都逃不过0、1、2、3、4这五个数。

这样一来，对于计算机处理有了有限的集合，有了运算法则，但是如果有限的集合内没有逆元的概念，集合是无法闭合的，这样就可能导致结果的不可预知。那么很容易理解，逆元对于有限集就像1之于乘法，0之于加法一样。

* 如果模数p为一个素数，那么对于整个正整数集合取模的结果去掉0就能生成一个乘法运算闭合的集合，该集合是一个素域，集合中的元素数量为p-1（去掉了0，这就是朴素的欧拉函数，欧拉函数只是一种找到元素个数的方法）
  * 这里p为素数的条件极为重要，这样就可以将集合框在一个范围内
  * 因为这集合中所有的元素和p都是互素的，没有公约数，即任意一个数与整个集合的乘机取p模得到的N‘==N
  * 得到N’==N，则可以说明，N'中包含1，即N中的每个元素都是存在乘法的单位元
* 如果p不是素数，即在集合N={1,2,...,n-1}中舍弃与n不互素的数字，假设p=m\*n（m,n均为素数），除去m的倍数，n的倍数，剩下集合中与p互素的数字一共有：(p-1)-(n-1)-(m-1)=(m-1)\*(n-1)，这样就界定了一个计算的集合了。

### 乘法逆元

#### 乘法逆元-大数分解

素数模数界定了一个有限的集合→可计算性；大数分解（两堆沙子混在一起如何区分出来）→计算的单向性

##### RSA算法

非对称密钥算法，选择两个较大的素数p和q，计算n=p*q，接下来界定一个集合，集合内全是与n互素的数，显然n不是素数，以为这必须在集合N={1,2,...,n-1}中舍弃与n不互素的数字。计算n=p\*q，m=(p-1)\*(q-1)，这样就界定了一个计算的集合了。

界定完集合N之后，就在N中选取一个数字e，计算e的逆元，结果就是私钥d=e的逆元，e和n就是公钥。

这里难点在于很难得到q和p。如果一个集合中的元素和模数都是互素的，那么乘法逆元一定存在，这种集合就是所谓的素域

#### 乘法逆元-离散对数问题

在上述的集合内，任意一个元素的任意次方模p的结果依然属于该集合。集散对数问题即是给定一个集合内的元素a以及另一个元素b，如何算出a的多少次方模为b。如此绕圈的规则就总结为数论。

### 公钥密码和对称密码

对于密码学而言，尤其是公钥密码学，群环域仅仅是为了定义一个框框，所有的计算限于这个框框，具体限制的方法为取模，在取模的作用下这个集合成了钟表。

对于公钥密码，数论只是颇有用武之地；而对于对称密码学领域，起关键作用的则是三个基本原则：

1. 混淆替换

   切断明文和密文之间的线性对应关系，替换在扩散的作用下会增加非线性特征

2. 作用扩散

   将非线性特征扩散到整个密文，明文片段之间的任何差异都会影响整个密文，使密文无章可循

3. 操作可逆

   加密解密使用同一个密钥，操作必须是可逆的，落实到对明文的操作即是异或运算









## 加解密算法

![image-20210612161147794](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210612161147794.png)

加解密系统典型组件包括算法和密钥（加密密钥+解密密钥）

* 加解密算法自身是固定不变的饿，一般公开可见
* 密钥最为关键，需要安全得保护起来；一般密钥再加密前按照特定得算法随机生成，长度越长，加密强度越大（密码强度取决于：①密钥长度；②破解密文需要的计算量）

根据加解密过程中所使用的密钥是否相同，算法可以分为

* 对称加密(Symmetric Cryptography/共有密钥加密，Common-key cryptography)

  * 加解密使用的密钥相同

  * 适用于大量数据的加解密过程；不能用于签名场景；需要提前安全地分发密钥

  * 优点：加解密效率（速度快、空间占用小）和加密强度很高

  * 缺点：

    * 需要参与者提前持有密钥，一旦泄露安全性就被破坏了
    * 如何在不安全的通道中提前分发密钥也是问题

  * 实现原理分为：

    * 分组密码：DES、3DES、AES、IDEA

      将明文切分位定长数据块作为基本加密单位，应用广泛

    * 序列密码：RC4

      又称流加密，只用在一些特定领域（如数字媒介的加密）

      每次只对一个字节或字符进行加密处理，且密码不断变化

      使用了一次性密码本的对称加密思想：通信双方每次使用跟明文等长的随机密钥串对明文进行加密处理，即每次通过伪随机数生成器来生成伪随机密钥串

* 非对称加密（Asymmertric Cryptography/公钥加密，Public-key Cryptography）

  * 优点：公私钥分开，解决了对称加密需要安全分发密钥的问题，无需安全通道来分发密钥
  * 公钥+私钥：私钥一般通过随机数算法生成，个人持有；公钥可以根据私钥产生，公开的
  * 缺点：
    * 处理速度（特别是生成密钥和解密过程）比较慢
    * 加密强度不如对称加密
  * 往往基于数学问题：大数质因子分解、离散对数、椭圆曲线
  * 经典的有：RSA、ElGamal、椭圆曲线（ECC）、SM2
  * 适用于签名场景或密钥协商过程，但是不适用于大量数据的加解密。除了SM2之外，大部分算法的签名速度要比验签速度慢
  * 由于公钥是公开的，所以任何人都可以利用它加密给定明文，因此可能存在选择明文攻击的风险
    * RSA、ECC引入了一定的保护机制：对相同的明文使用同样的密钥进行多次加密，避免选择明文攻击的破坏
    * 两种思路：
      * 对明文先进行变形，添加随机的字符或标记，再对添加后结果进行处理
      * 先用随机生成的临时密钥对明文进行对称加密，然后再对对称密钥进行加密


* 混合加密机制

  * 结合了对称加密和非对称加密的优点
  * 主要过程：先用非对称加密协商出一个临时的对称加密密钥（也叫会话密钥），然后再通过对称加密算法对所传递的大量数据进行快速的加密处理，较为经典的是安全超文本传输协议HTTPS
  * HTTPS：相对于HTTP以明文方式传输数据，HTTPS在传统的HTTP层和TCP层之间引入了Transport Layer Security/Secure Socket Layer（TLS/SSL）加密层来实现安全传输

### 公钥密码和对称密码的区别：

* 对称密码是基于置换和扩散
* 非对称密码是基于数学难题的
* 对称密码只使用一个密钥
* 公钥算法使用两个独立的密钥

## 对称密码学

分组密码是每次只能处理特定长度的一块数据的算法，分组的比特数称为分组长度，加密内容的长度超过分组密码的分组长度时，就要对分组密码算法进行迭代，迭代的方法称为分组密码的模式

DES和AES都是分组密码算法，DES和3DES的分组长度为64bit，AES为128bit

### 分组密码操作模式

#### 电子密码本模式

（Electionic code book mode,ECB）

最直接的消息加密方式，映射加密模式，每组的加密都是独立的，所以可以实现并行化。

优势：

* 高速实现
* 传输问题导致的消息中间一段受影响，不会影响后面的消息

缺陷：

映射加密，每组加密相互独立，可能会有代换攻击

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20181101224446276.png)

#### 密码分组链接模式

（CBC和CFB每组的密文都会影响后续所有组的密文）

（Cipher block chaining mode,CBC）

后一组的密文都受前一组密文的影响，第一组密文受初始向量IV影响，从而明文的重复排列不回反应在密文中

而且每次加密都会选择一个新的IV，则CBC模式就变成了一个概率加密方案，即相同的明文加密会生成不同的密文，如果IV数值得当，代换攻击就会失效

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20181101224522871.png)

缺陷：

* 如果某组密文出现错误，将影响这一整组及其以后分组的解密。由此也产生了CBC反转字节攻击
  * CBC反转字节攻击详解
    * 加密时，前一组明文会影响后面所有分组的密文
    * 但是解密时，一组密文只会影响这一组的解密结果和下一组的解密结果



#### 密码反馈模式

CFB和OFB都不需要使用分组密码的解密函数来解密密文

（Cipher feedback mode,CFB）

将前一个分组的密文加密后和当前分组的明文进行异或操作生成当前分组的密文，第一个明文分组通过初始化向量IV进行加密再与之进行异或操作得到第一个密文分组

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20181101224550618.png)

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20181101224613220.png)

缺陷：

* 与CBC类似，某一组密文中出现错误的bit，将影响这一组及其之后一整组的解密。同样也不可抵御重放攻击







#### 输出反馈模式

（Output feedback mode,OFB）

通过将明文分组和密码算法的输出及逆行异或操作来产生密文分组，也需要使用初始化向量（IV）

即形成一个既不依赖密文，也不依赖明文的同步序列密码

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20181101224635436.png)

缺陷：

* 由于每一组的加解密独立，降低了反转字节这样的主动攻击的成本



#### 计数器模式

（Counter mode,CTR）

每次加密都会生成一个不同的值来作为计数器的初始值，每个分组对应一个逐次累加的计数器，通过对计数器进行加密来生成密钥流，再将密钥流与明文分组进行异或操作得到密文分组

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20181101224700733.png)

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20181101224717855.png)







### DES算法

Data Encryption Standard，数字加密标准/与DES算法区分开

DES是一种典型的分组密码，将固定长度的明文通过复杂的操作变成同样长度密文

运行一次DES算法只能对64位长度的数据进行加密，所以如果处理大量数据就会花费相当长的时间，所以DES算法不适合对大数据进行处理（密钥实际上是56位参与DES运算（第8、16、24、32、40、48、56、64位是校验位， 使得每个密钥都有奇数个1））

DES属于对称加密算法，即该加密算法能够使用相同的密钥进行加密和解密

#### 设计原则：混淆和扩散

* 混淆

  使密文的统计特征与密钥的取值之间的关系尽可能复杂化，使密钥和明文以及密文之间的依赖性对密码分析者来说是无法利用的

* 扩散

  将每一位明文的影响尽可能迅速得作用到输出密文位中，以便在大量的密文中消除明文的统计结构，并且使每一位密钥的影响尽可能迅速地扩展到较多的密文位中，以防对密钥进行逐段破译。主要目的就是增加数据被破解的难度，造成雪崩效应，即在输入时即使发生了微小的变化都会对结果产生不可分辨性的变化。

#### DSE算法原理

使用Feistel框架（分组密码中的一种对称结构，使用的是对同一处理流程进行多次循环的方式）。DES采用16轮循环的加密，采用分组为64位分组（典型的分组大小为64位和128位），输入数据、密钥、输出密文都是按照64位进行处理

#### 加密流程

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_24VWUXQHSW3DQWC.png)

①将输入的明文进行初始置换，并将置换后的结果按照每组32位数据分为L、R两组

②将48位子密钥k[i]和32位R[i]组数据一同输入F函数进行处理，输出32位处理结果

③将F函数处理结果与32位的L[i]组数据按位进行异或处理

④将32位的异或处理结果赋值给R[i+1]，32位的R[i]赋值给L[i+1]

​	L[i+1]	=	R[i]

​	R[i+1]	=	L[i]^F((k[i],R[i]))

⑤将2，3，4步处理进行16次循环处理，得到R[16],L[16]

⑥将R[16],L[16]进行逆初始置换，得到想要的密文Y

注意点：最后一轮，R[15]->L[16]，L[15]-一系列运算->R[16]，后面又进行了一次交换，相当于没有变化，这里是为了保持16轮循环处理的过程一致，方便学习。

##### 初始置换处理IP(X)

置换：保持数据不变的情况下，打乱数据的位置顺序

DES算法中的置换处理会按照相应的置换表进行操作，通过置换处理可以打乱输入数据的顺序，使输入的数据变得面目全非，当然也会造成雪崩效应

例如：

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_BVGQF87E35ZQSSH.png)

​	比如0*0位置是58，则将数据中的第58个Bit位移动到第一个Bit位上去，如此循环完成置换，比如这个表64位，则需要置换64次得出结果

```c
const unsigned char IP_Table[64] =
{
    58, 50, 42, 34, 26, 18, 10, 2,
    60, 52, 44, 36, 28, 20, 12, 4,
    62, 54, 46, 38, 30, 22, 14, 6,
    64, 56, 48, 40, 32, 24, 16, 8,
    57, 49, 41, 33, 25, 17,  9, 1,
    59, 51, 43, 35, 27, 19, 11, 3,
    61, 53, 45, 37, 29, 21, 13, 5,
    63, 55, 47, 39, 31, 23, 15, 7
};
//Bit_IP_Table：置换后的数据数组
//BitPlain：置换前的数据数组
int IP_Substitution(const unsigned char* BitPlain, unsigned char* Bit_IP_Table)
{
    int ret = 0;
 
    for (int i = 0; i < 64; i++)
    {
        Bit_IP_Table[i] = BitPlain[IP_Table[i] - 1];
    }
 
    return ret;
}
```

##### LR分组

将初始置换的结果进行分组，每组32位数据。这里理论和实际情况分组方法不一致

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_G3QENXMTD5J97WX.png)

理论分组代码：

```c
int Create_LR_Group(const unsigned char *Bit_IP_Table, unsigned char *BitL_Table, unsigned char*BitR_Table)
{
    for (int i = 0; i < 8; i++)
    {
        //左半边拷贝
        memcpy(&BitL_Table[i * 4], &Bit_IP_Table[i * 8], 4);
        //右半边拷贝
        memcpy(&BitR_Table[i * 4], &Bit_IP_Table[i * 8 + 4], 4);
    }
    return 0;
}
```

实际分组代码：

```c
unsigned char Bit_IP_Table[64];      //初始置换后的明文表
unsigned char BitL_Table[17][32];    //L表Bit组
unsigned char BitR_Table[17][32];    //R表Bit组
 
memcpy(BitL_Table[0], Bit_IP_Table,         32);
memcpy(BitR_Table[0], &Bit_IP_Table[32],    32);
```

##### F函数

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_VQHSEWUUPX4WR2Z.png)

1. 将32位的R组进行扩展置换，生成48位的数据
2. 将置换后的48位结果与输入的48位子密钥进行异或运算，得到48位的运行结果
3. 将48位的结果进行6*8的八组数据，按照对应的S盒进行八个S盒置换，生成8个4Bit的数据
4. 合并八个4bit，得到32位结果
5. 将32位进行置换，得到最终结果

###### 扩展置换E（32->48）

目的：在加密数据的过程中制造一些雪崩效应，使用数据块中的1位，对下一步操作中影响更多位，从而产生扩散效果

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_KSWKQ7ZWZEJ876K.png)

```c
//扩展置换E表     f函数内
const unsigned char E_Table[48] =
{
    32,    1,    2,     3,     4,     5,
    4,     5,    6,     7,     8,     9,
    8,     9,    10,    11,    12,    13,
    12,    13,   14,    15,    16,    17,
    16,    17,   18,    19,    20,    21,
    20,    21,   22,    23,    24,    25,
    24,    25,   26,    27,    28,    29,
    28,    29,   30,    31,    32,     1
};
int E_Substitution(const unsigned char* BitR_Table, unsigned char* BitE_Table)
{
    int ret = 0;
    for (int i = 0; i < 48; i++)
    {
        BitE_Table[i] = BitR_Table[E_Table[i] - 1];
    }
    return ret;
}
```

###### S盒置换((6->4)*8)

F函数中最重要的处理。将异或运算之后的结果进行分组，对每组数据分别处理，第一组（1-6bit）对应S1盒，第二组（7-13bit）对应S2盒。。。

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_8CFCBM9Z9A5DNJS.png)

如上图，每个S盒为4*16

每组数据的第一个bit成为最重要位（MSB），最后一个bit位称为最不重要位(LSB)。MSB和LSB组合成一个2bit位的数据，这个数据对应S盒的行号，中间的四位组合成4bit的数据，对应S盒的列号。

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_S6UHK78CFUZWZ2U.png)

将定位到的整数转换位4个二进制数据，则完成S盒转换

```c
//S盒置换  f函数内
const unsigned char S_Table[8][4][16] =
{
    //S1盒
    14, 4,  13, 1,  2,  15, 11, 8,  3,  10, 6,  12, 5,  9,  0,  7,
    0,  15, 7,  4,  14, 2,  13, 1,  10, 6,  12, 11, 9,  5,  3,  8,
    4,  1,  14, 8,  13, 6,  2,  11, 15, 12, 9,  7,  3,  10, 5,  0,
    15, 12, 8,  2,  4,  9,  1,  7,  5,  11, 3,  14, 10, 0,  6,  13,
 
    //S2盒
    15, 1,  8,  14, 6,  11, 3,  4,  9,  7,  2,  13, 12, 0,  5,  10,
    3,  13, 4,  7,  15, 2,  8,  14, 12, 0,  1,  10, 6,  9,  11, 5,
    0,  14, 7,  11, 10, 4,  13, 1,  5,  8,  12, 6,  9,  3,  2,  15,
    13, 8,  10, 1,  3,  15, 4,  2,  11, 6,  7,  12, 0,  5,  14, 9,
 
    //S3盒
    10, 0,  9,  14, 6,  3,  15, 5,  1,  13, 12, 7,  11, 4,  2,  8,
    13, 7,  0,  9,  3,  4,  6,  10, 2,  8,  5,  14, 12, 11, 15, 1,
    13, 6,  4,  9,  8,  15, 3,  0,  11, 1,  2,  12, 5,  10, 14, 7,
    1,  10, 13, 0,  6,  9,  8,  7,  4,  15, 14, 3,  11, 5,  2,  12,
 
    //S4盒
    7,  13, 14, 3,  0,  6,  9,  10, 1,  2,  8,  5,  11, 12, 4,  15,
    13, 8,  11, 5,  6,  15, 0,  3,  4,  7,  2,  12, 1,  10, 14, 9,
    10, 6,  9,  0,  12, 11, 7,  13, 15, 1,  3,  14, 5,  2,  8,  4,
    3,  15, 0,  6,  10, 1,  13, 8,  9,  4,  5,  11, 12, 7,  2,  14,
 
    //S5盒
    2,  12, 4,  1,  7,  10, 11, 6,  8,  5,  3,  15, 13, 0,  14, 9,
    14, 11, 2,  12, 4,  7,  13, 1,  5,  0,  15, 10, 3,  9,  8,  6,
    4,  2,  1,  11, 10, 13, 7,  8,  15, 9,  12, 5,  6,  3,  0,  14,
    11, 8,  12, 7,  1,  14, 2,  13, 6,  15, 0,  9,  10, 4,  5,  3,
 
    //S6盒
    12, 1,  10, 15, 9,  2,  6,  8,  0,  13, 3,  4,  14, 7,  5,  11,
    10, 15, 4,  2,  7,  12, 9,  5,  6,  1,  13, 14, 0,  11, 3,  8,
    9,  14, 15, 5,  2,  8,  12, 3,  7,  0,  4,  10, 1,  13, 11, 6,
    4,  3,  2,  12, 9,  5,  15, 10, 11, 14, 1,  7,  6,  0,  8,  13,
 
    //S7盒
    4,  11, 2,  14, 15, 0,  8,  13, 3,  12, 9,  7,  5,  10, 6,  1,
    13, 0,  11, 7,  4,  9,  1,  10, 14, 3,  5,  12, 2,  15, 8,  6,
    1,  4,  11, 13, 12, 3,  7,  14, 10, 15, 6,  8,  0,  5,  9,  2,
    6,  11, 13, 8,  1,  4,  10, 7,  9,  5,  0,  15, 14, 2,  3,  12,
 
    //S8盒
    13, 2,  8,  4,  6,  15, 11, 1,  10, 9,  3,  14, 5,  0,  12, 7,
    1,  15, 13, 8,  10, 3,  7,  4,  12, 5,  6,  11, 0,  14, 9,  2,
    7,  11, 4,  1,  9,  12, 14, 2,  0,  6,  10, 13, 15, 3,  5,  8,
    2,  1,  14, 7,  4,  10, 8,  13, 15, 12, 9,  0,  3,  5,  6,  11
};
 
unsigned char Bit_Xor[8][6];          //存放异或运算的结果
unsigned char Bit_Integer[8][4];      //将整数变成Bit位
unsigned char Row;                    //S盒的行号
unsigned char Col;                    //S盒的列号
unsigned char Integer;                //从S盒中取得的32位整数
 
for (int i = 0; i < 8; i++)
{
    //计算S盒的行号和列号
    Row = (Bit_Xor[i][0] << 1) + Bit_Xor[i][5];
    Col = (Bit_Xor[i][1] << 3) + (Bit_Xor[i][2] << 2) + (Bit_Xor[i][3] << 1) + Bit_Xor[i][4];
 
    //从S盒中取得整数
    Integer = S_Table[i][Row][Col];
 
    //将取得的4Bit数转换成Bit组
    for (int j = 0; j < 4; j++)
    {
        Bit_Integer[i][j] = Integer >> (3 - j) & 1;
    }
}
```

###### P置换

与初始IP置换类似，只是打乱了数据的位置

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_MZ2KHSVSZWXPC6T.png)

```c
const unsigned char P_Table[32] =
{
    16, 7,  20, 21, 29, 12, 28, 17,
    1,  15, 23, 26, 5,  18, 31, 10,
    2,  8,  24, 14, 32, 27, 3,  9,
    19, 13, 30, 6,  22, 11, 4,  25
};
 
int P_Substitution(const unsigned char *Bit_Integer, unsigned char* BitP_Table)
{
    int ret = 0;
 
    for (int i = 0; i < 32; i++)
    {
        BitP_Table[i] = Bit_Integer[P_Table[i] - 1];
    }
 
    return ret;
}
```

##### DES中的循环以及逆初始值置换

###### 循环

F函数输出的32位数据与L[i]按位异或，得到32运算结果，并赋值给R[i+1]，而R[i]的数据则原封不动得赋值给L[i+1]，如此循环16次

​	L[i+1]	=	R[i]

​	R[i+1]	=	L[i]^F((k[i],R[i]))

```c
for (int i = 0; i < 16; i++)
{
    //将R组和子密钥组进行F函数运算
    DES_F_Function(BitR_Table[i], BitSubKey[i], Bit_F_Out);
 
    //L组盒F函数的输出结果进行异或运算
    DES_XOR(BitL_Table[i], Bit_F_Out, BitR_Table[i + 1], 32);
 
    //Li+1 = Ri
    memcpy(BitL_Table[i + 1], BitR_Table[i], 32);
}
 
//L[16]和R[16]进行交叉合并
memcpy(BitRL_Table,         BitR_Table[16], 32);
memcpy(&BitRL_Table[32],    BitL_Table[16], 32);
```

最后将L16和R16进行交叉合并，即R16作为前32位数据，L16作为后32位数据，合并成一个64位数据。

###### 逆初始值置换

例：

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_XET4C6ZM75G2Z4D.png)

```c
const unsigned char reIP_Table[64] =
{
    40, 8, 48, 16, 56, 24, 64, 32,
    39, 7, 47, 15, 55, 23, 63, 31,
    38, 6, 46, 14, 54, 22, 62, 30,
    37, 5, 45, 13, 53, 21, 61, 29,
    36, 4, 44, 12, 52, 20, 60, 28,
    35, 3, 43, 11, 51, 19, 59, 27,
    34, 2, 42, 10, 50, 18, 58, 26,
    33, 1, 41,  9, 49, 17, 57, 25
};
 
int reIP_Substitution(const unsigned char *BitRL_Table, unsigned char *Bit_reIP_Table)
{
    int ret = 0;
 
    for (int i = 0; i < 64; i++)
    {
        Bit_reIP_Table[i] = BitRL_Table[reIP_Table[i] - 1];
    }
 
    return ret;
}
```

经过逆初始值置换，就可以得到密文得二进制形式，将这些二进制转换为16进制，则得到想要得密文。

#### DES密钥生成算法

在DES的循环处理中，F函数有两个输入数据：R组数据、子密钥数据。而且这边每一个循环都要使用一个不同的子密钥，16轮循环也就是16个子密钥数据。

DES子密钥生成流程图：

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_H924J3NY6P4FQBA.png)

##### PC-1置换

在第一步，会将64位的密钥处理成56位。这说明密钥数据中有8位是参与子密钥生成的。

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_4FGC4QX4QG3EDN7.png)

可以发现，PC-1置换表是一个7*8矩阵，少了8、16、24、32、40、56、64，这八个位置被当作了校验位（如果没有校验位，就会出现，多组密钥可以解密同一个加密，如下案例）

如果没有校验位，可以看出，对于相同的数据，使用不同的密钥生成的加密数据和解密结果都是相同的。

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_QNXX2DS6FPZVNCE.png)

```c
const unsigned char PC_1_Table[56] =
{
    57, 49, 41, 33, 25, 17, 9,  1,
    58, 50, 42, 34, 26, 18, 10, 2,
    59, 51, 43, 35, 27, 19, 11, 3,
    60, 52, 44, 36, 63, 55, 47, 39,
    31, 23, 15, 7,  62, 54, 46, 38,
    30, 22, 14, 6,  61, 53, 45, 37,
    29, 21, 13, 5,  28, 20, 12, 4
};
 
int PC_1_Substitution(const unsigned char *BitKey, unsigned char *BitKey_PC_1)
{
    int ret = 0;
    for (int i = 0; i < 56; i++)
    {
        BitKey_PC_1[i] = BitKey[PC_1_Table[i] - 1];
    }
    return ret;
}
```

##### 密钥生成算法&左移处理

经过PC-1处理后，进行数据分组，与DES算法类似，都是前后分组（28+28），前28给C组，后28给D组。

将得到的两组数据分别进行左移处理，当i=1、2、9、16，C、D两组左移以为，其他左移两位。可以发现，所以左移位数加起来，恰好一共需要移动28位。即移动前等于最后移动后的数据，C[0]=C[16]、D[0]=D[16]

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_R3NXC9HMGZ6M3AM.png)

```c
const unsigned char Bit_Round[16] =
{
    1, 1, 2, 2,
    2, 2, 2, 2,
    1, 2, 2, 2,
    2, 2, 2, 1
};

int BitRound_L(const unsigned char* SrcBitGroup, unsigned char* DesBitGroup, int nBit)
{
    int ret = 0;
 
    memcpy(DesBitGroup,             &SrcBitGroup[nBit], 28 - nBit);
    memcpy(&DesBitGroup[28 - nBit], SrcBitGroup,        nBit);
 
    return ret;
}
 
//将C、D两组进行轮转移位操作    左移
BitRound_L(BitC_Table[i], BitC_Table[i + 1], Bit_Round[i]);
BitRound_L(BitD_Table[i], BitD_Table[i + 1], Bit_Round[i]);
```

##### 密钥生成算法PC-2置换

将C、D两组左移后的数据进行合并成一个56Bit的数据块，经过PC-2置换处理后就会变成一个48Bit的子密钥。16个循环即形成16个子密钥

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_F5H8VBJF9ADVVT8.png)

```c
const unsigned char PC_2_Table[48] =
{
    14, 17, 11, 24, 1,  5,  3,  28,
    15, 6,  21, 10, 23, 19, 12, 4,
    26, 8,  16, 7,  27, 20, 13, 2,
    41, 52, 31, 37, 47, 55, 30, 40,
    51, 45, 33, 48, 44, 49, 39, 56,
    34, 53, 46, 42, 50, 36, 29, 32
};
 
int PC_2_Substitution(const unsigned char *BitKey, unsigned char *SubKey)
{
    int ret = 0;
 
    for (int i = 0; i < 48; i++)
    {
        SubKey[i] = BitKey[PC_2_Table[i] - 1];
    }
 
    return ret;
}
```

#### 解密方法：

将生成的16组子密钥按照相反的顺序输入到F函数中，可以完成解密。比如输入时是1->16，解密时就应该是16->1

#### 数据转换方式：

```c
//第一种   0x34 --->  00110100
int ByteToBit(const unsigned char *Byte, unsigned char *Bit)
{
    int ret = 0;
 
    for(int i = 0; i < 8; i ++)
    {
        for (int j = 0; j < 8; j++)
        {
            Bit[i * 8 + j] = Byte[i] >> (7 - j) & 1;
        }
    }
 
    return ret;
}
 
//第二种   0x34 --->  00101100
int ByteToBit(const unsigned char *ByteStr, unsigned int *BitStr)
{
    for (int i = 0; i < 64; i++)
    {
        BitStr[i] = ByteStr[i / 8] >> (i % 8) & 1;
    }
}
```

### [DES算法优化](https://bbs.pediy.com/thread-253558.htm#msg_header_h3_2)



### 3DES算法

三重DES操作：加密->解密->加密，处理过程和加密强度优于DES





### AES算法

Advanced Encryption Standard，高级加密标准

由于DES密钥长度为56Bit，所以算法的理论安全强度为2<sup>56</sup>。随后出现3DES的加密方法，但是时间是DES的三倍多，64Bit的分组大小相对较小。AES密码与分组密码Rijndael基本上完全一致，Rijndael分组大小和密钥大小都可以为128位、192位、256位（这里密钥长度每增加64位，算法的循环次数就增加2轮，则128位循环10轮、192位循环12轮、256位循环14轮）。所以只有128Bit的Rijndael算法才称为AES算法。

#### 数学知识

##### 素域

* 有限域
  * 有限个元素组成的，这个集合内可以执行加减乘和逆运算
  * 域中包含元素的个数为域的阶
  * 只有当m是一个素数幂时，即m=p<sup>n</sup>(其中n为正整数是p的次数，p为素数)，阶为m的域才存在，p为这个有限域的特征
  * 最为直观为为阶位素数的域，即n=1。称为素域、拥有素数个元素的素数域、伽罗瓦域
  * 域的两种操作为，模整数加法和整数乘法模p

素域内的算数运算规则：

1. 加法和乘法都是通过模p实现的
2. 任何一个元素a的加法逆元都是由公式：a+(a的逆元)=0 mod p得到的
3. 任何一个非零元素a的乘法逆元定义为a\*(a的逆元) = 1

注意：GF(2)是一个十分重要的素域，也就是存在的最小的有限域。GF(2)的加法，即模2加法与异或(XOR)门等价；GF(2)的乘法与逻辑与(and)门等价

##### 扩展域

阶不是素数的有限域的加法和乘法都不能用模整数加法和整数乘法模p表示。阶大于1的域称为扩展域。要处理扩展域，就要使用不同的符号表示扩展域内的元素，使用不同的规则执行扩展域内元素的算数运算。

对于扩展域GF(2<sup>m</sup>)中，元素不是用整数表示的，而是用吓唬为GF(2)中元素的多项式表示，多项式最大的幂(度)为m-1

例如：GF(2<sup>8</sup>)中，A(x)=a<sub>7</sub>x<sup>7</sup>+a<sub>6</sub>x<sup>6</sup>+a<sub>5</sub>x<sup>5</sup>+a<sub>4</sub>x<sup>4</sup>+a<sub>3</sub>x<sup>3</sup>+a<sub>2</sub>x<sup>2</sup>+a<sub>1</sub>x<sup>1</sup>+a<sub>0</sub>

​								A=(a<sub>7</sub>,a<sub>6</sub>,a<sub>5</sub>,a<sub>4</sub>,a<sub>3</sub>,a<sub>2</sub>,a<sub>1</sub>,a<sub>0</sub>)

###### 扩展域GF(2<sup>m</sup>)中的加减法

通常将拓展域中的加法当作异或运算来处理。因为扩展域

C(x)=A(x)±B(x)=ΣC<sub>i</sub>x<sup>i</sup>	C<sub>i</sub>=(a<sub>i</sub>±b<sub>i</sub>)mod2

###### 扩展域GF(2<sup>m</sup>)中的乘法

主要运用在AES算法的列混淆层（Mix Column）

将扩展域中的两个元素用多项式形式展开，然后使用标准的多项式乘法规则将两个多项式相乘

此时其度会大于m-1，就需要对其进行化简：将两个多项式相乘的结果除以一个不可约多项式，最后的结果就是最后的余数（AES算法中的不可约多项式：P(x)=x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x<sup>1</sup>+1）

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_3RNGQGNWRNX5DAA.png)

#### AES算法原理

SubBytes->ShiftRows->MixColumns->AddRoundKey

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20180831004432398)

主要有密钥加法成（轮密钥加法）、字节代换层、行唯一层、列混淆层

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_XJ9BX7PYB2XD7VJ.png)

##### 密钥加法层

对于扩展域加减法，在扩展域中加减法操作和异或运算等价，这里只需要将两个输入的数据（明文+子密钥）进行按字节异或操作就会得到运行的结果

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_W6HMQKZYX3JNJCR.png)

代码实现：

```c
int AddRoundKey(unsigned char(*PlainArray)[4], unsigned char(*ExtendKeyArray)[44], unsigned int MinCol)
{
    int ret = 0;
 
    for (int i = 0; i < 4; i++)
    {
        for (int j = 0; j < 4; j++)
        {
            PlainArray[i][j] ^= ExtendKeyArray[i][MinCol + j];
        }
    }
 
    return ret;
}
```



##### 字节代换层

让输入的数据通过S_box表完成从一个字节到另一个字节的映射，

* 将256字节的S盒作为一维数组（建议）
* 定义为16*16的二维数组，将输入数据的每个字节高四位作为第一个下标。低四位作为第二个下标

##### 行位移

将输入的数据作为一个4*4的字节矩阵进行处理的，然后将这个矩阵的字节进行位置上的置换。ShiftRow子层属于AES手动的扩散层，目的是将单个位上的变换扩散到影响整个状态，从而达到雪崩效应

##### 列混淆

属于扩散层，是AES算法中主要的扩散元素，混淆了输入矩阵的每一列，使输入的每个字节都会影响到4个输出字节。行位移子层和列混淆子层的组合使得经过三层处理后，矩阵的每个字节都依赖于16个明文字节



#### AES密钥生成

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/813468_CHWREHFQKJRYJR8.png)



#### AES解密流程





### IDEA

设计类似于3DES，密钥长度增加到128位，具有更好的加密强度



## 对称密码两大难题

### 密钥分配问题

对称密码中，加解密使用同一个密钥，存在密钥配送问题

解决方案：

1. 通过事先共享密钥来解决

2. 通过密钥分配中心来解决

3. 通过Diffie-Hellman密钥交换来解决

   根据交换的信息各自生成密钥

   #### 离散对数问题：

   指对于一个很大的素数p，已知g为p的模循环群的原根，给定任意x，求解X=g^x mod p是可以很快获取的。但是在已知p，g和X的前提下，逆向求x很难，这也是ECC类加密算法的基础。

   #### Diffie-Hellman密钥交换协议

   * Alice 和 Bob 两个人协商密钥，先公开商定 p，g；
   * Alice 自行选取私密的整数 x，计算 X=g^x mod p，发送 X 给 Bob；
   * Bob 自行选取私密的整数 y，计算 Y=g^y mod p，发送 Y 给 A；
   * Alice 根据 x 和 Y，求解共同密钥 Z_A=Y^x mod p；
   * Bob 根据 X 和 y，求解共同密钥 Z_B=X^y mod p。

   实际上，Alice 和 Bob 计算出来的结果将完全相同，因为在 mod p 的前提下，Y^x =(g^y)^x =g^(xy) = (g^x)^y=X^y。而信道监听者在已知 p，g，X，Y 的前提下，无法求得 Z。

4. 通过公钥密码来解决

### 数字签名问题

无法确保数字签名是出自某个特定的人，并且各方对此没有异议











## 非对称加密/公钥密码

组成部分：明文、加密算法、公钥、私钥、密文、解密算法

特点：

* 仅根据密码算法和加密密钥无法确定解密密钥
* 两个密钥一个加密一个解密

### 公钥密码分析

* 穷举攻击——使用长密钥
* 从给定的公钥计算私钥
* 穷举消息攻击
  * 在发送的消息后附加一个随机数

### RSA

利用了对大数进行质因子分解困难的特性

RSA不仅可以用作公钥密码，还能用于数字签名

#### 密钥生成

1. 随机选取两个不相等的质数p和q（实际应用中，这两个质数越大就越难破解）

2. n= p*q，n的长度即为密钥长度

   如n=61×53=3233→110010100001，为12位，那么密钥就是21位

3. 计算n的欧拉函数：φ(n) = (p-1)(q-1)

   如：上述例子中φ(3233) = 60*52

4. 随机选择整数e，**1< e < φ(n)，且e与φ(n) 互质。**

   如选e=17

5. 计算e对于φ(n)的模反元素d

   ed ≡ 1 (mod φ(n))

   如d=2753

6. 将n和e封装成公钥，n和d封装成私钥

   上述公钥为(3233,17)，私钥就是（3233, 2753）

#### 可靠性

一共六个数字：p、q、n、φ(n)、e、d

私钥泄露即为泄露d

​		（1）ed≡1 (mod φ(n))。只有知道e和φ(n)，才能算出d。

　　（2）φ(n)=(p-1)(q-1)。只有知道p和q，才能算出φ(n)。

　　（3）n=pq。只有将n因数分解，才能算出p和q。

那么问题就聚焦到了n的因式分解了，即：对极大整数做因式分解的难度决定了RSA算法的可靠性

#### 加密与解密

* 使用公钥（n,e）加密明文
  * m<sup>e</sup> ≡ c (mod n)，c为密文
  * 可以看出，只能加密比n小的整数m，如果比n大，怎么办？
    * 将长信息分割成若干短消息，分别加密
    * 先用对称加密算法的密钥加密信息，再用RSA公钥加密对称加密算法的密钥
* 使用私钥（n,d）解密密文
  * c<sup>d</sup>  ≡ m (mod n)

##### 证明私钥解密

ｍ<sup>e</sup> ≡ c (mod n)→c = m<sup>e</sup> - kn→带入解密公式(m<sup>e</sup> - kn)<sup>d</sup> ≡ m (mod n)→即m<sup>ed</sup>=m (mod n)

又ed = 1 (mod φ(n))→ed = hφ(n)+1

即：　m<sup>hφ(n)+1</sup> ≡ m (mod n)

分类：

1. m和n互质

   根据欧拉定理：m<sup>φ(n)</sup> ≡ 1 (mod n)

   则m<sup>hφ(n)+1</sup> =（m<sup>φ(n)</sup>）<sup>h</sup>×m = m (mod n)

2. m和n不是互质

   由于n=q*p，而p，q互质，所以m必然等于kq或kq

   (kp)<sup>q-1</sup> ≡ 1 (mod q)

   [(kp)<sup>q-1</sup>]<sup>h(p-1)</sup> × kp ≡ kp (mod q)

   (kp)<sup>ed</sup> ≡ kp (mod q)

   (kp)<sup>ed</sup> = tq + kpa

   (kp)<sup>ed</sup> = t'pq + kp（t能被p整除）

   则m<sup>ed</sup> ≡ m (mod n)

![image-20210615150901332](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210615150901332.png)

#### 针对RSA的攻击

1. 强力攻击：穷举，尝试所有可能的私钥
2. 数学分析攻击：试图分解两个素数的乘积
3. 计时攻击：记录计算机解密所花的时间
4. 选择密文攻击：利用RSA算法的性质

## 混合密码技术

组成机制：

1. 使用对称密码加密信息
2. 通过伪随机数生成器生成对称密码加密中使用的会话密钥
3. 用公钥加密会话密钥
4. 从混合密码系统外部赋予公钥密码时使用的密钥







## 消息认证

* 安全攻击
  * 泄密
  * 传输分析
  * 伪装：伪造信息，声称来自合法实体
  * 内容修改
  * 顺序修改
  * 计时修改
  * 发送方否认
  * 接收方否认

### 消息加密函数

完整信息的密文作为对信息的认证

### 单向散列函数

又称消息摘要函数，哈希函数/杂凑函数，根据内容计算出散列值，将任意长度的信息映射成一个固定长度的信息，检查信息完整性

如：MD4、MD5、SHA-1、SHA-256、SHA-384、SHA-512、SHA-3、SM3

性质：

* 输出长度固定
* 快速计算出散列值
* 消息不同，散列值必然不同
* 单向性

Hash（哈希或散列）算法，又被称为指纹或摘要算法，可以将任意长度的二进制明文串映射为较短的（通常固定长度的）二进制串，并且不同的明文很难映射为相同的Hash值

优秀的Hash算法：

* 正向快速
* 逆向困难
* 输入敏感
* 碰撞避免
  * 又称为抗碰撞性，可分为
    * 抗弱碰撞性：给定原文前提下，无法找到与其碰撞的其他原文
    * 抗强碰撞性：无法找到任意两个可碰撞的原文

常见的Hash算法：

* Message Digest（MD）：MD4+MD5 
* SHA(Secure Hash Algorithm)系列算法
* 国内的SM3算法

缺点：

* ***只能解决完整性问题，无法解决认证问题***，认证可以消息认证码和数字签名

#### 实际应用

1. 检测软件是否被篡改
2. 基于口令的加密（PBE）
3. 消息认证码：检测防止通信过程中的错误、伪装和篡改
4. 数字签名
5. 伪随机数生成器
6. 一次性口令

数字摘要是Hash的主要用途之一，对原始的数字内容进行Hash运算，获取唯一的摘要值

因为Hash抗碰撞性，所以数字摘要可以检测内容是否被篡改过

##### 与加密结合用于认证

* 加密消息及散列码：E[K,M || H(M)]
* 对称加密散列码：M || E(K,H(M))
* 公钥解密散列码：M ||E(PRa,H(M))      数字签名方案

* 对称密码加密签名：E(K,M || E(PRa,H(M)))
* 带秘密值的散列码：M || H(M || S)
* 对称密码加密带秘密值得散列码：E(K,M || H(M || K))



Hash攻击与防护

一般敏感信息都会先进行Hash运算，再存入数据库，防止信息泄露。但是常见的字符串都被做成字典， 可以采用加盐的方式，方式泄露

#### SHA-1

![img](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/20180831100750907)

#### MD5

填充消息→附加消息长度→初始化缓冲区→分组处理消息→输出消息摘要

填充消息

1. 将字符串分割成512位为一个分组，形如N*512+R
   1. 最后多出不足512位的R部分，先填一个1，再接无数个0，直到补足512位
   2. R=0，就加上一个10000的512位分组；
   3. R>448，则除了补满这个分组，还需要再补上一个512的分组（**因为最后要留64位来存放字符串的原长**）
2. 一个512位的字符串分组要分成16个32位的子分组，每个子分组以字节为单位通过小端规则存入一个32位的变量中

附加消息长度

1. 之后成了(N+1)\*512或者(N+2)\*512位，最低的64位预留，保存原字符串的长度（字符个数\*8bit），如果长度的二进制数大于64，则保留最低的64位，同样，对length也类似操作，子分组之后按小端规则填入

2. 缓冲区长度：128位

   MD5有四个32位的被称作链接变量的整数参数：A=0x67452301，B=0xefcdab89，C=0x98badcfe，D=0x10325476。用四个32位的寄存器（A,B,C,D）表示

   存在内存中就按小端规则排列：01 23 45 67 89 ab cd ef …32 10

3. 消息处理过程：算法的核心是压缩函数，由四轮运算组成，每轮进行16步迭代，每轮使用不同的逻辑函数，记为F，G，H，I。T为事先产生的表格，包含64项，每项32位。16个分组，每组32位

   ![image-20210615195327225](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210615195327225.png)

   1. 压缩函数：每一轮包含对缓冲区ABCD的16步操作所组成的一个序列

      a←b+((a + g(b,c,d) + X[k] + T[i])<<<s)

      * a,b,c,d→缓冲区的四个字

      * g→基本逻辑函数F,G,H,I之一

        ![image-20210615214330641](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210615214330641.png)

      * <<<s→对32位字循环左移s位

      * X[k]→

      * T[i]→表T中的第i个32位字

      * +→模2<sup>32</sup>的加

分组处理消息

​	CV<sub>0</sub>=IV

​	CV<sub>i</sub>=H<sub>MD5</sub>(CV<sub>i-1</sub>,Y<sub>i</sub>)

输出消息摘要

​	MD=CV<sub>L</sub>







### 消息认证码

完整性+认证，简称MAC码

任意长度的message + 发送者和接受者之间共享的密钥 -> 固定长度的MAC值

与HASH对比：

* 都是根据任意长度的消息输出固定长度的数据
* MAC码比HASH函数多出一个共享密钥->认证

利用对称加密（共享密钥）对消息完整性进行保护，需要提前共享密钥，并且如果密钥被多方同时拥有，无法定位追踪消息的真实来源



缺点：

* 无法解决对第三方的证明和防止否认（数字签名可以解决）



实现：

- 使用单向散列函数实现
  比如HMAC。
- 使用分组密码实现
  使用AES之类的分组密码可以实现消息认证码。关于分组密码的详细内容，后面我们会做详细说明。
- 其他实现
  其他实现方法如：流密码和公钥密码等。





![image-20210615160703384](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210615160703384.png)

对MAC码的攻击：

* 重放攻击：将事先拦截保存的正确的MAC值不断重放来攻击
  * 对应防御技术：
    * 每次发送消息都赋予一个递增的序号包含在消息中
    * 抑或是使用时间戳，但是这要求发送者和接受者保持时钟一致，还要考虑进通信延迟
    * nonce（现时）：在每次通信前，接受者给发送者发送一个一次性的随机数，发送者发送的消息中包含此值
  
* 暴力破解

  暴力破解：在攻击者可以同时看到明文和密文的情况下，可以猜解key

  如：k>n，(k为密钥长度位数，n为mac长度位数)

  对一个明文会产生2<sup>k</sup>个mac结果，但是mac长度为n，所以mac结果最多只能为2<sup>n</sup>个，所以可能存在的情况是多个key会产出相同的mac，那么平均来说2<sup>k</sup>/2<sup>n</sup>=2<sup>k-n</sup>个key，对应匹配一个MAC，所以可以多重循环确定k

  第一轮：得知MAC<sub>1</sub>=C<sub>k</sub>(M<sub>1</sub>)，匹配的key数量≈2<sup>(k-n)</sup>

  第二轮：得知MAC<sub>2</sub>=C<sub>k</sub>(M<sub>2</sub>)，再从上一轮匹配的key中进行再次筛选，匹配的key数量约为2<sup>(k-n)</sup>/2<sup>n</sup>=2<sup>(k-2n)</sup>

  依次往下，直到确定key，一般如果k=a×n，就需要a轮

  

* 生日攻击

* 不需要密钥的攻击

  

  ![image-20210615080319795](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210615080319795.png)



对mac函数的要求：

* 无法构造C<sub>K</sub>(M')=C<sub>K</sub>(M)
* MAC函数具有均匀的分布
* 令M‘=f(M)，那么Pr[C<sub>K</sub>=C<sub>K</sub>(M')] = 2<sup>-n</sup>



### 重放攻击VS中间人攻击

* 重放攻击
  * 又称重播攻击、回放攻击、新鲜性攻击
  * hacker发送一个目的主机已经接收过的包，来达到欺骗系统的目的
  * 防御方案：
    * 时间戳
    * 序号
    * 现时
* 中间人攻击
  * 是一种间接的入侵方式
  * 与原始的两台计算机建立活动连接并允许其读取或修改传递的信息；这种“拦截数据->修改数据->发送数据”的过程称为会话劫持





### 数字签名

* 数字签名基本要求

  * 签名必须是与消息相关的二进制位串
  * 签名必须使用发送方特有的信息，防伪造或否认
  * 签名的产生和识别比较容易
  * 伪造数字签名在计算上是不可行的
  * 保存数字签名的拷贝是可行的

* 数字签名体制

  * 签名算法Signature Algorithm
    * Sig(M)=S
    * 签名密钥K是秘密的，只有发方掌握
  * 验证算法Verification Algorithm
    * Ver(S)={0,1}
    * 公开
  * 从M和S很难推出签名密钥K或伪造一个M’使得M‘和S可被证实为真

* 数字签名分类

  * 直接数字签名

    只涉及通信双方

    * 用发送方的私钥对整条消息进行加密来产生签名——保密、鉴别、签名
    * 用发送方的私钥对消息的hash码进行加密——保密、数字签名（加密和签名的先后顺序）

    缺点：

    依赖于发送方的保密密钥，如果声称私钥丢失，可以赖账

    改进：给签名的信息包含一个时间戳，并且一旦发现私钥丢失，需要报告给授权中心

  * 仲裁数字签名

    发给B之前，仲裁者对消息和签名进行测试，检查来源和内容，然后加上日期和验证通过的标识发给B

    * X和A之间共享Kxa，Y与A之间共享Kay
    * X和Y之间共享密钥Kxy
    * 公钥加密方式，仲裁者不可以看见消息

* 使用非对称加密算法，证实内容的完整性，并确认其来源
  * 但是和公钥加密不同：
    * 公钥加密就是用公钥加密消息，用私钥解密密文（保密性）
    * 而数字签名是使用私钥对消息（摘要）生成签名，然后使用公钥解密验证签名（认证和签名）
    
  * 例子：公钥加密
  
    ![image-20210615155921742](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210615155921742.png)
  
    1. 既能实现保密性，又能完成认证和签名
    2. 一次通信中要进行四次复杂的公钥算法

* 方法：
  * 直接对消息进行签名（耗时）
  * 对消息的散列值进行签名
* 实现：单向散列函数+公钥密码技术

特殊数字签名技术：盲签名、多重签名、群签名、环签名

* 对数字签名的攻击
  * 单向散列函数
    * 使用高强度的HASH函数来抵御针对抗碰撞性的攻击
  * 公钥密码
    * 使用公钥证书确认自己得到的公钥真的属于通信对方
* 利用数字签名攻击公钥密码

可以确保所记录信息的合法性，可以证明某个公钥为某个实体拥有，确保任何篡改都能被检测出来，从而实现对用户公钥的安全分发。一般需要由证书认证机构（Certification Authority,CA）来进行签发和背书。

证书是公钥信任的基础，对其生命周期进行安全管理十分关键

* 加密数字证书（Encryption Certificate）
  * 往往用于保护加密用途的公钥
* 签名验证数字证书（Signature Certificate）
  * 用于签名用途的公钥



## 密钥管理

### 双重加密方案

A-E<sub>A</sub>(P)->B

A<-E<sub>B</sub>(E<sub>A</sub>(P))-B

A-D<sub>A</sub>(E<sub>B</sub>(E<sub>A</sub>(P)))-D<sub>A</sub>(E<sub>A</sub>(E<sub>B</sub>(P)))-E<sub>B</sub>(P)->B

要求：E<sub>B</sub>(E<sub>A</sub>(P)) = E<sub>A</sub>(E<sub>B</sub>(P))

### 对称密钥管理技术

需求：

* 双方共享密钥，不为他人所知
* 密钥经常变动，以保证通信安全

密钥分配方法：

* 密钥由A选择，并亲自给B
* 第三方选择密钥亲自交给A和B
* A/B使用最近使用过的密钥加密新密钥再发给另一方
* A和B与第三方C都有秘密通道，C可以分别发给AB

N个用户需要N（N-1）/2个密钥 

#### 典型的对称密钥分配模式

KDC：密钥分配中心——负责分发密钥给需要的用户

AB建立逻辑连接，需要用一个一次性的会话密钥来保护数据传输

![image-20210615221154442](%E5%AF%86%E7%A0%81%E5%AD%A6.assets/image-20210615221154442.png)

#### 分散式密钥控制

不需要KDC，每个节点需要保存(n-1)个主密钥

### 会话密钥类型

​	数据加密密钥

​	PIN加密密钥

​	文件加密密钥



## 安全协议



## PKI/CA

### PKI体系

公钥可以通过证书机制来进行保护，但是证书的生成、分发、撤销等步骤并未涉及

PKI体系解决了证书生命周期相关的认证和管理问题，是建立在公私钥基础上实现安全可靠传递消息和身份确认的一个通用框架。

#### PKI的基本组件

* CA：Certification Authority，负责证书的颁发和吊销，接收来自RA的请求，是最核心的部分
* RA：Registration Authority，对用户身份进行验证，校验数据合法性，负责登记，审核通过就发给CA
* 证书数据库：存放证书；

用户证书的签发有两种方式：

* 用户自己生成公私钥，然后CA来对公钥内容进行签名（私钥只有用户持有）
* CA直接生成证书（内含公钥）和对应的私钥给用户（用户和CA都持有私钥）

由于CA无法强制收回颁发的证书，所以实现证书的作废，需要维护一个吊销证书列表（Certificate Revocation List,CRL），用来记录已经吊销的证书序号















## 可信计算

可信的概念：值得信任，系统的运行符合预期的结果，没有出现未预期的结果或故障

可信计算要达到的要求：

* 验证用户的身份
* 验证平台软硬件配置的正确性
* 验证应用程序的完整性和合法性
* 平台之间的可验证性

三个安全属性：

* 可鉴别性
* 完整性
* 机密性

基本思想：首先在计算机终端创建一个可信根，根据可信根将信任从计算机硬件扩展到os，再到应用程序形成信任链

可信计算在信息系统中通过可信度量将信任继承传递，实现提高终端的可信、可用以及安全性的目标

三个方面：

* 可信可用，安全交互
* 主动防疫
* 自主创新，安全可控



### 度量

#### 静态度量

在运行环境初装或者重启时对其镜像的度量。逐级度量，先启动的软件对后一级启动的软件进行度量，度量值验证成功则标志可信链从前一级软件向后一级软件的成功传递。

例：以操作系统为例

可信操作系统启动时基于硬件的可信启动链，对启动链上的UEFI、loader、OS的image进行静态度量，静态度量的结果通过云上可信管理服务来验证，以判断系统是否被改动

#### 动态度量

动态度量即是在系统运行时动态获取其运行特征，根据规则或模型分析判断系统是否运行正常



### 可信根

系统的安全基础也是安全起点，在可信网络环境中所有安全设备都信任可信根，可信应用将会从下层获得安全支撑

通常是可信硬件芯片，通过芯片厂家植入在可信硬件中的算法和密钥以及集成的专用微控制器对软件栈进行度量和验证来确保可信。

根据安全芯片和在其上运行的可信软件基(Trusted Software Stack)分类，有三种：

* Trusted Platform Module(TPM)

  四个主要功能：

  * 对称/非对称加密
  * 安全存储
  * 完整性度量
  * 签名认证

* Trusted Cryptography Module(TCM)

* Trusted Platform Contorl Module(TPCM)

基于可信根，对系统引导程序、系统程序、重要配置参数和通信应用程序等进行可信验证，并在应用程序的所有执行环节进行动态验证。

TCG认为一个可信平台必须包含三个可信根：

* 可信度量根（Root of Trust for Measurement,RTM）

  平台启动时首先执行的一段程序，是由CRTM控制的计算引擎

* 可信存储根（Root of Trust for Storage,RTS）

  由TPM芯片中的PCR和存储根密钥（Storage Root Key，SRK）组成。

* 可信报告根（Root of Trust for Report,RTR）

  由TPM芯片中的PCR和背书密钥（Endorsement Key，EK）组成。EK仅用于两种操作：创建TPM的拥有者、创建AIK及其授权数据





